/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.0.4
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : t.Popper = e() }(this, (function () { "use strict"; function t(t) { const e = t.offsetParent, o = e && e.nodeName; return o && "BODY" !== o && "HTML" !== o ? e : window.document.documentElement } function e(t, e) { if (1 !== t.nodeType) return []; const o = window.getComputedStyle(t, null); return e ? o[e] : o } function o(t) { return "HTML" === t.nodeName ? t : t.parentNode || t.host } function n(t) { if (!t || -1 !== ["HTML", "BODY", "#document"].indexOf(t.nodeName)) return window.document.body; const { overflow: i, overflowX: r, overflowY: s } = e(t); return /(auto|scroll)/.test(i + s + r) ? t : n(o(t)) } function i() { const t = window.document.body, e = window.document.documentElement; return { height: Math.max(t.scrollHeight, t.offsetHeight, e.clientHeight, e.scrollHeight, e.offsetHeight), width: Math.max(t.scrollWidth, t.offsetWidth, e.clientWidth, e.scrollWidth, e.offsetWidth) } } function r(t) { let e; if ("HTML" === t.nodeName) { const { width: t, height: o } = i(); e = { width: t, height: o, left: 0, top: 0 } } else e = { width: t.offsetWidth, height: t.offsetHeight, left: t.offsetLeft, top: t.offsetTop }; return e.right = e.left + e.width, e.bottom = e.top + e.height, e } function s(t) { const n = t.nodeName; return "BODY" !== n && "HTML" !== n && ("fixed" === e(t, "position") || s(o(t))) } function f(e) { return s(t(e)) ? "fixed" : "absolute" } function p(t) { const o = -1 !== navigator.appVersion.indexOf("MSIE 10"); let n; if (o) try { n = t.getBoundingClientRect() } catch (t) { n = {} } else n = t.getBoundingClientRect(); const i = { left: n.left, top: n.top, right: n.right, bottom: n.bottom, width: n.right - n.left, height: n.bottom - n.top }; if ("HTML" === t.nodeName && o) { const { scrollTop: t, scrollLeft: e } = window.document.documentElement; i.top -= t, i.bottom -= t, i.left -= e, i.right -= e } let r = n.width - (t.clientWidth || n.right - n.left), s = n.height - (t.clientHeight || n.bottom - n.top); if (r || s) { const o = e(t); r -= Number(o.borderLeftWidth.split("px")[0]) + Number(o.borderRightWidth.split("px")[0]), s -= Number(o.borderTopWidth.split("px")[0]) + Number(o.borderBottomWidth.split("px")[0]) } return i.right -= r, i.width -= r, i.bottom -= s, i.height -= s, i } function l(t, e = "top") { const o = "top" === e ? "scrollTop" : "scrollLeft", n = t.nodeName; if ("BODY" === n || "HTML" === n) { const t = window.document.documentElement; return (window.document.scrollingElement || t)[o] } return t[o] } function a(o, i, r = !1, s = !1) { const f = n(i), a = p(o), d = p(i), h = { top: a.top - d.top, left: a.left - d.left, bottom: a.top - d.top + a.height, right: a.left - d.left + a.width, width: a.width, height: a.height }; if (r && !s) { const t = l(f, "top"), e = l(f, "left"); h.top -= t, h.bottom -= t, h.left -= e, h.right -= e } else if (t(o).contains(f) && "BODY" !== f.nodeName) { const t = l(i, "top"), e = l(i, "left"); h.top += t, h.bottom += t, h.left += e, h.right += e } const c = e(i), u = Number(c.borderTopWidth.split("px")[0]), m = Number(c.borderLeftWidth.split("px")[0]); return h.top -= u, h.bottom -= u, h.left -= m, h.right -= m, h } function d(t, e = "top") { const i = n(t), r = l(i, e); return -1 === ["BODY", "HTML"].indexOf(i.nodeName) ? r + d(o(i), e) : r } function h(e, p, l) { let h = { top: 0, left: 0 }; const c = t(e); if ("viewport" === l) { const { left: t, top: o } = r(c), { clientWidth: n, clientHeight: i } = window.document.documentElement; if ("fixed" === f(e)) h.right = n, h.bottom = i; else { h = { top: 0 - o, right: n - t + d(e, "left"), bottom: i - o + d(e, "top"), left: 0 - t } } } else { let t; if (t = "scrollParent" === l ? n(o(e)) : "window" === l ? window.document.body : l, "BODY" === t.nodeName) { const { height: t, width: e } = i(); h.right = e, h.bottom = t } else h = a(t, c, s(e)) } return h.left += p, h.top += p, h.right -= p, h.bottom -= p, h } function c(t, e, o) { if (-1 === t.indexOf("auto")) return t; const n = h(o, 0, "scrollParent"), i = { top: e.top - n.top, right: n.right - e.right, bottom: n.bottom - e.bottom, left: e.left - n.left }, r = Object.keys(i).sort((t, e) => i[e] - i[t])[0], s = t.split("-")[1]; return r + (s ? "-" + s : "") } const u = ["native code", "[object MutationObserverConstructor]"]; var m = t => u.some(e => (t || "").toString().indexOf(e) > -1); const g = ["Edge", "Trident", "Firefox"]; let b = 0; for (let t = 0; t < g.length; t += 1)if (navigator.userAgent.indexOf(g[t]) >= 0) { b = 1; break } var w = m(window.MutationObserver) ? function (t) { let e = !1, o = 0, n = document.createElement("span"); return new MutationObserver(() => { t(), e = !1 }).observe(n, { attributes: !0 }), () => { e || (e = !0, n.setAttribute("x-index", o), o += 1) } } : function (t) { let e = !1; return () => { e || (e = !0, setTimeout(() => { e = !1, t() }, b)) } }; function v(t, e) { return Array.prototype.find ? t.find(e) : t.filter(e)[0] } function x(t, e, o) { if (Array.prototype.findIndex) return t.findIndex(t => t[e] === o); const n = v(t, t => t[e] === o); return t.indexOf(n) } var M = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var o = arguments[e]; for (var n in o) Object.prototype.hasOwnProperty.call(o, n) && (t[n] = o[n]) } return t }; function y(t) { return M({}, t, { right: t.left + t.width, bottom: t.top + t.height }) } function O(t) { const e = window.getComputedStyle(t), o = parseFloat(e.marginTop) + parseFloat(e.marginBottom), n = parseFloat(e.marginLeft) + parseFloat(e.marginRight); return { width: t.offsetWidth + n, height: t.offsetHeight + o } } function E(t) { const e = { left: "right", right: "left", bottom: "top", top: "bottom" }; return t.replace(/left|right|bottom|top/g, t => e[t]) } function L(t, e, o, n) { n = n.split("-")[0]; const i = O(e), r = { position: t.position, width: i.width, height: i.height }, s = -1 !== ["right", "left"].indexOf(n), f = s ? "top" : "left", p = s ? "left" : "top", l = s ? "height" : "width", a = s ? "width" : "height"; return r[f] = o[f] + o[l] / 2 - i[l] / 2, r[p] = n === p ? o[p] - i[a] : o[E(p)], r } function N(e, o, n) { const i = "fixed" === e.position, r = e.isParentTransformed; return a(n, t(i && r ? n : o), i, r) } function T(t) { const e = [!1, "ms", "webkit", "moz", "o"], o = t.charAt(0).toUpperCase() + t.slice(1); for (let n = 0; n < e.length - 1; n++) { const i = e[n], r = i ? `${i}${o}` : t; if (void 0 !== window.document.body.style[r]) return r } return null } function B(t) { return t && "[object Function]" === {}.toString.call(t) } function P(t, e) { return t.some(({ name: t, enabled: o }) => o && t === e) } function D(t, e, o) { const n = v(t, ({ name: t }) => t === e); return !!n && t.some(t => t.name === o && t.enabled && t.order < n.order) } function H(t) { return "" !== t && !isNaN(parseFloat(t)) && isFinite(t) } function W(t) { return "BODY" !== t.nodeName && ("none" !== e(t, "transform") || (o(t) ? W(o(t)) : t)) } function C(t, e) { return window.removeEventListener("resize", e.updateBound), e.scrollElement && e.scrollElement.removeEventListener("scroll", e.updateBound), e.updateBound = null, e.scrollElement = null, e.eventsEnabled = !1, e } function S(t, e, o) { return (void 0 === o ? t : t.slice(0, x(t, "name", o))).forEach(t => { t.enabled && B(t.function) && (e = t.function(e, t)) }), e } function A(t, e) { Object.keys(e).forEach((function (o) { !1 !== e[o] ? t.setAttribute(o, e[o]) : t.removeAttribute(o) })) } function j(t, e) { Object.keys(e).forEach(o => { let n = ""; -1 !== ["width", "height", "top", "right", "bottom", "left"].indexOf(o) && H(e[o]) && (n = "px"), t.style[o] = e[o] + n }) } function F(t, e, o, i) { o.updateBound = i, window.addEventListener("resize", o.updateBound, { passive: !0 }); let r = n(t); return "BODY" === r.nodeName && (r = window), r.addEventListener("scroll", o.updateBound, { passive: !0 }), o.scrollElement = r, o.eventsEnabled = !0, o } var R = { computeAutoPlacement: c, debounce: w, findIndex: x, getBoundaries: h, getBoundingClientRect: p, getClientRect: y, getOffsetParent: t, getOffsetRect: r, getOffsetRectRelativeToCustomParent: a, getOuterSizes: O, getParentNode: o, getPopperOffsets: L, getPosition: f, getReferenceOffsets: N, getScroll: l, getScrollParent: n, getStyleComputedProperty: e, getSupportedPropertyName: T, getTotalScroll: d, getWindowSizes: i, isFixed: s, isFunction: B, isModifierEnabled: P, isModifierRequired: D, isNative: m, isNumeric: H, isTransformed: W, removeEventListeners: C, runModifiers: S, setAttributes: A, setStyles: j, setupEventListeners: F }; function Y(t, e, o) { return !!e.escapeWithReference && (t.flipped && k(t.originalPlacement, o) || k(t.originalPlacement, o), !0) } function k(t, e) { const o = t.split("-")[0]; return o === e.split("-")[0] || o === E(e) } const U = { placement: "bottom", eventsEnabled: !0, onCreate: () => { }, onUpdate: () => { }, modifiers: { shift: { order: 100, enabled: !0, function: function (t) { const e = t.placement, o = e.split("-")[0], n = e.split("-")[1]; if (n) { const e = t.offsets.reference, i = y(t.offsets.popper), r = { y: { start: { top: e.top }, end: { top: e.top + e.height - i.height } }, x: { start: { left: e.left }, end: { left: e.left + e.width - i.width } } }, s = -1 !== ["bottom", "top"].indexOf(o) ? "x" : "y"; t.offsets.popper = M({}, i, r[s][n]) } return t } }, offset: { order: 200, enabled: !0, function: function (t, e) { const o = t.placement, n = t.offsets.popper; let i; return H(e.offset) ? i = [e.offset, 0] : (i = e.offset.split(" "), i = i.map((e, n) => { const i = e.match(/(\d*\.?\d*)(.*)/), r = +i[1], s = i[2]; let f = -1 !== o.indexOf("right") || -1 !== o.indexOf("left"); 1 === n && (f = !f); const p = f ? "height" : "width"; if ("%" === s || "%r" === s) { return y(t.offsets.reference)[p] / 100 * r } if ("%p" === s) { return y(t.offsets.popper)[p] / 100 * r } if ("vh" === s || "vw" === s) { let t; return t = "vh" === s ? Math.max(document.documentElement.clientHeight, window.innerHeight || 0) : Math.max(document.documentElement.clientWidth, window.innerWidth || 0), t / 100 * r } return "px" === s ? +r : +e })), -1 !== t.placement.indexOf("left") ? (n.top += i[0], n.left -= i[1] || 0) : -1 !== t.placement.indexOf("right") ? (n.top += i[0], n.left += i[1] || 0) : -1 !== t.placement.indexOf("top") ? (n.left += i[0], n.top -= i[1] || 0) : -1 !== t.placement.indexOf("bottom") && (n.left += i[0], n.top += i[1] || 0), t }, offset: 0 }, preventOverflow: { order: 300, enabled: !0, function: function (e, o) { const n = o.boundariesElement || t(e.instance.popper), i = h(e.instance.popper, o.padding, n); o.boundaries = i; const r = o.priority; let s = y(e.offsets.popper); const f = { left() { let t = s.left; return s.left < i.left && !Y(e, o, "left") && (t = Math.max(s.left, i.left)), { left: t } }, right() { let t = s.left; return s.right > i.right && !Y(e, o, "right") && (t = Math.min(s.left, i.right - s.width)), { left: t } }, top() { let t = s.top; return s.top < i.top && !Y(e, o, "top") && (t = Math.max(s.top, i.top)), { top: t } }, bottom() { let t = s.top; return s.bottom > i.bottom && !Y(e, o, "bottom") && (t = Math.min(s.top, i.bottom - s.height)), { top: t } } }; return r.forEach(t => { s = M({}, s, f[t]()) }), e.offsets.popper = s, e }, priority: ["left", "right", "top", "bottom"], padding: 5, boundariesElement: "scrollParent" }, keepTogether: { order: 400, enabled: !0, function: function (t) { const e = y(t.offsets.popper), o = t.offsets.reference, n = t.placement.split("-")[0], i = Math.floor; return -1 !== ["top", "bottom"].indexOf(n) ? (e.right < i(o.left) && (t.offsets.popper.left = i(o.left) - e.width), e.left > i(o.right) && (t.offsets.popper.left = i(o.right))) : (e.bottom < i(o.top) && (t.offsets.popper.top = i(o.top) - e.height), e.top > i(o.bottom) && (t.offsets.popper.top = i(o.bottom))), t } }, arrow: { order: 500, enabled: !0, function: function (t, e) { if (!D(t.instance.modifiers, "arrow", "keepTogether")) return t; let o = e.element; if ("string" == typeof o) { if (o = t.instance.popper.querySelector(o), !o) return t } else if (!t.instance.popper.contains(o)) return t; const n = t.placement.split("-")[0], i = y(t.offsets.popper), r = t.offsets.reference, s = -1 !== ["left", "right"].indexOf(n), f = s ? "height" : "width", p = s ? "top" : "left", l = s ? "left" : "top", a = s ? "bottom" : "right", d = O(o)[f]; r[a] - d < i[p] && (t.offsets.popper[p] -= i[p] - (r[a] - d)), r[p] + d > i[a] && (t.offsets.popper[p] += r[p] + d - i[a]); let h = r[p] + r[f] / 2 - d / 2 - y(t.offsets.popper)[p]; return h = Math.max(Math.min(i[f] - d, h), 0), t.arrowElement = o, t.offsets.arrow = {}, t.offsets.arrow[p] = h, t.offsets.arrow[l] = "", t }, element: "[x-arrow]" }, flip: { order: 600, enabled: !0, function: function (t, e) { if (P(t.instance.modifiers, "inner")) return t; if (t.flipped && t.placement === t.originalPlacement) return t; const o = h(t.instance.popper, e.padding, e.boundariesElement); let n = t.placement.split("-")[0], i = E(n), r = t.placement.split("-")[1] || "", s = []; return s = "flip" === e.behavior ? [n, i] : e.behavior, s.forEach((f, p) => { if (n !== f || s.length === p + 1) return t; n = t.placement.split("-")[0], i = E(n); const l = y(t.offsets.popper), a = t.offsets.reference, d = "left" === n && Math.floor(l.right) > Math.floor(a.left) || "right" === n && Math.floor(l.left) < Math.floor(a.right) || "top" === n && Math.floor(l.bottom) > Math.floor(a.top) || "bottom" === n && Math.floor(l.top) < Math.floor(a.bottom), h = "left" === n && Math.floor(l.left) < Math.floor(o.left) || "right" === n && Math.floor(l.right) > Math.floor(o.right) || "top" === n && Math.floor(l.top) < Math.floor(o.top) || "bottom" === n && Math.floor(l.bottom) > Math.floor(o.bottom), c = -1 !== ["top", "bottom"].indexOf(n), u = !!e.flipVariations && (c && "start" === r && Math.floor(l.left) < Math.floor(o.left) || c && "end" === r && Math.floor(l.right) > Math.floor(o.right) || !c && "start" === r && Math.floor(l.top) < Math.floor(o.top) || !c && "end" === r && Math.floor(l.bottom) > Math.floor(o.bottom)); (d || h || u) && (t.flipped = !0, (d || h) && (n = s[p + 1]), u && (r = function (t) { return "end" === t ? "start" : "start" === t ? "end" : t }(r)), t.placement = n + (r ? "-" + r : ""), t.offsets.popper = L(t.instance.state, t.instance.popper, t.offsets.reference, t.placement), t = S(t.instance.modifiers, t, "flip")) }), t }, behavior: "flip", padding: 5, boundariesElement: "viewport" }, inner: { order: 700, enabled: !1, function: function (t) { const e = t.placement, o = e.split("-")[0], n = y(t.offsets.popper), i = y(t.offsets.reference), r = -1 !== ["left", "right"].indexOf(o), s = -1 === ["top", "left"].indexOf(o); return n[r ? "left" : "top"] = i[e] - (s ? n[r ? "width" : "height"] : 0), t.placement = E(e), t.offsets.popper = y(n), t } }, hide: { order: 800, enabled: !0, function: function (t) { if (!D(t.instance.modifiers, "hide", "preventOverflow")) return t; const e = t.offsets.reference, o = v(t.instance.modifiers, t => "preventOverflow" === t.name).boundaries; if (e.bottom < o.top || e.left > o.right || e.top > o.bottom || e.right < o.left) { if (!0 === t.hide) return t; t.hide = !0, t.attributes["x-out-of-boundaries"] = "" } else { if (!1 === t.hide) return t; t.hide = !1, t.attributes["x-out-of-boundaries"] = !1 } return t } }, applyStyle: { order: 900, enabled: !0, gpuAcceleration: !0, function: function (t, e) { const o = { position: t.offsets.popper.position }, n = { "x-placement": t.placement }, i = Math.round(t.offsets.popper.left), r = Math.round(t.offsets.popper.top), s = T("transform"); return e.gpuAcceleration && s ? (o[s] = "translate3d(" + i + "px, " + r + "px, 0)", o.top = 0, o.left = 0, o.willChange = "transform") : (o.left = i, o.top = r, o.willChange = "top, left"), j(t.instance.popper, M({}, o, t.styles)), A(t.instance.popper, M({}, n, t.attributes)), t.offsets.arrow && j(t.arrowElement, t.offsets.arrow), t }, onLoad: function (t, e, o, n, i) { const r = N(i, e, t); return o.placement = c(o.placement, r, e), e.setAttribute("x-placement", o.placement), o } } } }; class q { constructor(t, e, o = {}) { this.scheduleUpdate = () => requestAnimationFrame(this.update), this.update = w(this.update.bind(this)), this.options = M({}, q.Defaults, o), this.state = { isDestroyed: !1, isCreated: !1 }, this.reference = t.jquery ? t[0] : t, this.popper = e.jquery ? e[0] : e, this.modifiers = Object.keys(q.Defaults.modifiers).map(t => M({ name: t }, q.Defaults.modifiers[t])), this.modifiers = this.modifiers.map(t => { const e = o.modifiers && o.modifiers[t.name] || {}; return M({}, t, e) }), o.modifiers && (this.options.modifiers = M({}, q.Defaults.modifiers, o.modifiers), Object.keys(o.modifiers).forEach(t => { if (void 0 === q.Defaults.modifiers[t]) { const e = o.modifiers[t]; e.name = t, this.modifiers.push(e) } })), this.state.position = f(this.reference), this.modifiers = this.modifiers.sort((t, e) => t.order - e.order), this.modifiers.forEach(t => { t.enabled && B(t.onLoad) && t.onLoad(this.reference, this.popper, this.options, t, this.state) }), this.state.isParentTransformed = W(this.popper.parentNode), this.update(); const n = this.options.eventsEnabled; n && this.enableEventListeners(), this.state.eventsEnabled = n } update() { if (this.state.isDestroyed) return; let t = { instance: this, styles: {}, attributes: {}, flipped: !1, offsets: {} }; this.state.position = f(this.reference), j(this.popper, { position: this.state.position }), t.offsets.reference = N(this.state, this.popper, this.reference), t.placement = c(this.options.placement, t.offsets.reference, this.popper), t.originalPlacement = this.options.placement, t.offsets.popper = L(this.state, this.popper, t.offsets.reference, t.placement), t = S(this.modifiers, t), this.state.isCreated ? this.options.onUpdate(t) : (this.state.isCreated = !0, this.options.onCreate(t)) } destroy() { return this.state.isDestroyed = !0, P(this.modifiers, "applyStyle") && (this.popper.removeAttribute("x-placement"), this.popper.style.left = "", this.popper.style.position = "", this.popper.style.top = "", this.popper.style[T("transform")] = ""), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this } enableEventListeners() { this.state.eventsEnabled || (this.state = F(this.reference, this.options, this.state, this.scheduleUpdate)) } disableEventListeners() { this.state.eventsEnabled && (window.cancelAnimationFrame(this.scheduleUpdate), this.state = C(this.reference, this.state)) } } return q.Utils = R, q.placements = ["auto", "auto-start", "auto-end", "top", "top-start", "top-end", "right", "right-start", "right-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end"], q.Defaults = U, q }));